/*
 * Copyright (c) 2012-2014 Wind River Systems, Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/kernel.h>
#include <zephyr/shell/shell.h>
#include <zephyr/crypto/crypto.h>
#include <stdlib.h>

LOG_MODULE_REGISTER(main);

#define TASK_STACK_SIZE		 1024
#define PRIORITY                7
static struct k_thread temp_id;
K_THREAD_STACK_DEFINE(temp_stack, TASK_STACK_SIZE);

#define MAX_ARGUMNETS 3
#define MAX_ARGU_SIZE 10
static uint8_t arguments[MAX_ARGUMNETS][MAX_ARGU_SIZE];
struct k_event aes_event;

static const struct device *const aes_dev = DEVICE_DT_GET(DT_NODELABEL(aes));

static const uint32_t au32MyAESKey[8] = {
	0x10214387, 0x0f1f3e7c, 0xf8f1e3c6, 0x8c193265, 0xcb962d5a,
	0xb56bd6ad, 0x5ab56bd6, 0xad5ab468
};

static const uint8_t __aligned(2) au8InputData[1024] = {
	0x02, 0x0B, 0x54, 0x02, 0x07, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x07, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0x8E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x07, 0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x07, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0xFD, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x08, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x08, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x6C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x08, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x08, 0xB6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0xDB, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x09, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x09, 0x4A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x09, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x09, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x09, 0xB9, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x09, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x0A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0A, 0x28, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x0A, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x0A, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0A, 0x97, 0xEF, 0x70,
	0x06, 0xD2, 0x03, 0xD2, 0x06, 0x80, 0x02, 0xC2, 0x06, 0x12, 0x04, 0x7F,
	0x22, 0x00, 0x20, 0x03, 0x03, 0x02, 0x06, 0x19, 0x75, 0x86, 0x5A, 0x75,
	0x86, 0x80, 0x90, 0x1E, 0xFD, 0xE0, 0x44, 0x02, 0xF0, 0x12, 0x01, 0x77,
	0x50, 0x40, 0xE4, 0x78, 0x29, 0xF6, 0x78, 0x2E, 0xF6, 0xC2, 0x02, 0xE4,
	0x78, 0x3E, 0xF6, 0x12, 0x02, 0x29, 0x20, 0x02, 0x05, 0x12, 0x02, 0xD7,
	0x80, 0xF8, 0x78, 0x33, 0xE6, 0x18, 0x46, 0x70, 0xE8, 0x78, 0x3C, 0xE6,
	0x78, 0x2A, 0x60, 0x0D, 0xE6, 0xFE, 0x08, 0xE6, 0xF5, 0x82, 0x8E, 0x83,
	0x74, 0x12, 0xF0, 0x80, 0xC8, 0xE6, 0xFE, 0x08, 0xE6, 0xF5, 0x82, 0x8E,
	0x83, 0x74, 0x0A, 0xF0, 0x80, 0xBB, 0x90, 0x1E, 0xFC, 0xE0, 0x54, 0x0F,
	0x60, 0xB3, 0x53, 0xE8, 0xFE, 0x12, 0x03, 0x7C, 0x53, 0xDC, 0xBF, 0x90,
	0xE1, 0x00, 0xE0, 0x54, 0x7F, 0xF0, 0x75, 0x86, 0x5A, 0x75, 0x86, 0x40,
	0x12, 0x0B, 0x3C, 0xE4, 0x90, 0x1E, 0xFD, 0xF0, 0x90, 0x1E, 0xFC, 0xE0,
	0x78, 0x40, 0xF6, 0xE6, 0xFF, 0xC4, 0x54, 0xF0, 0xF0, 0xEF, 0x54, 0x0F,
	0x64, 0x0F, 0x60, 0x0E, 0x90, 0x00, 0x05, 0xE0, 0x44, 0x02, 0xF0, 0x75,
	0x86, 0x5A, 0x75, 0x86, 0x10, 0x22, 0xC2, 0x03, 0x90, 0x1E, 0xFD, 0x74,
	0x01, 0xF0, 0x22, 0xA2, 0x01, 0xE4, 0xFC, 0x33, 0xFD, 0x7E, 0x00, 0x78,
	0x03, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x24, 0xEC, 0xF5, 0x82,
	0x74, 0x1E, 0x3E, 0xF5, 0x83, 0xE0, 0x30, 0xE0, 0x2C, 0xED, 0xCE, 0xEC,
	0xCE, 0x78, 0x03, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x24,
	0xEC, 0xF5, 0x82, 0x74, 0x1E, 0x3E, 0xF5, 0x83, 0x74, 0x04, 0xF0, 0x74,
	0xEC, 0x2F, 0xF5, 0x82, 0x74, 0x1E, 0x3E, 0xAF, 0x82, 0x78, 0x2A, 0xF6,
	0x08, 0xEF, 0xF6, 0x80, 0x02, 0xC3, 0x22, 0xC2, 0x00, 0xE4, 0x78, 0x3C,
	0xF6, 0x78, 0x38, 0xF6, 0x08, 0xF6, 0x78, 0x2A, 0xE6, 0xFE, 0x08, 0xE6,
	0xFF, 0xF5, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD,
	0x78, 0x32, 0xEC, 0xF6, 0x08, 0xED, 0xF6, 0xEF, 0x24, 0x04, 0x78, 0x36,
	0xF6, 0xE4, 0x3E, 0x18, 0xF6, 0xED, 0x4C, 0x60, 0x0E, 0x78, 0x3A, 0x30,
	0x01, 0x04, 0x76, 0x2F, 0x80, 0x02, 0x76, 0x2E, 0x08, 0x76, 0x00, 0x78,
	0x2A, 0xE6, 0xFE, 0x08, 0xE6, 0xF5, 0x82, 0x8E, 0x83, 0xA3, 0xE0, 0xFF,
	0x30, 0xE2, 0x04, 0xD2, 0x05, 0x80, 0x02, 0xC2, 0x05, 0xEF, 0x78, 0x2F,
	0x30, 0xE3, 0x04, 0x76, 0x01, 0x80, 0x02, 0x76, 0x04, 0xB2, 0x01, 0xD3,
	0x22, 0x78, 0x38, 0xE6, 0xFE, 0x08, 0xE6, 0xFF, 0x4E, 0x60, 0x44, 0x78,
	0x3B, 0xEF, 0x26, 0xF6, 0x18, 0xEE, 0x36, 0xF6, 0x78, 0x35, 0xE6, 0xFC,
	0x08, 0xE6, 0xFD, 0xF5, 0x82, 0x8C, 0x83, 0xA3, 0xA3, 0xA3, 0xE0, 0x2F,
	0xF0, 0x8D, 0x82, 0x8C, 0x83, 0xA3, 0xA3, 0xA3, 0xE0, 0x70, 0x20, 0x18,
	0xE6, 0xFE, 0x08, 0xE6, 0xFF, 0xF5, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xE0,
	0x04, 0xF0, 0x8F, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xE0, 0x70, 0x08, 0x8D,
	0x82, 0x8C, 0x83, 0xA3, 0xE0, 0x04, 0xF0, 0x78, 0x32, 0xE6, 0xFE, 0x08,
	0xE6, 0xFF, 0x4E, 0x60, 0x55, 0x78, 0x2F, 0xE6, 0x64, 0x04, 0x70, 0x39,
	0xC2, 0x00, 0x78, 0x35, 0xE6, 0xFC, 0x08, 0xE6, 0xF5, 0x82, 0x8C, 0x83,
	0xA3, 0xA3, 0xA3, 0xE0, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x3E, 0xFE,
	0xD3, 0xEF, 0x94, 0x00, 0xEE, 0x94, 0x01, 0x40, 0x1A, 0xE4, 0x9D, 0xFF,
	0x74, 0x01, 0x9C, 0xFE, 0x78, 0x38, 0xF6, 0x08, 0xEF, 0xF6, 0xC3, 0x78,
	0x33, 0xE6, 0x9F, 0xF6, 0x18, 0xE6, 0x9E, 0xF6, 0x22, 0xC2, 0x00, 0x78,
	0x32, 0xE6, 0xFF, 0x08, 0xE6, 0x78, 0x38, 0xCF, 0xF6, 0x08, 0xEF, 0xF6,
	0xE4, 0x78, 0x32, 0xF6, 0x08, 0xF6, 0x22, 0x78, 0x3E, 0xE6, 0x14, 0x60,
	0x16, 0x04, 0x60, 0x03, 0x02, 0x03, 0x65, 0x90, 0xE1, 0x00, 0xE0, 0x44,
	0x80, 0xF0, 0x75, 0xDF, 0xC4, 0x75, 0xDC, 0x4C, 0x75, 0xDD, 0xE0, 0x78,
	0x3E, 0x76, 0x01, 0x78, 0x2A, 0xE6, 0xFE, 0x08, 0xE6, 0xF5, 0x82, 0x8E,
	0x83, 0xA3, 0xE0, 0x20, 0xE3, 0x03, 0x12, 0x03, 0x7C, 0x30, 0x05, 0x06,
	0x12, 0x03, 0x7C, 0x12, 0x03, 0x66, 0x53, 0xDF, 0xFB, 0x78, 0x35, 0xE6,
	0xFE, 0x08, 0xE6, 0xFF, 0x78, 0x2F, 0xE6, 0xFD, 0x7C, 0x00, 0x12, 0x03,
	0x9C, 0x30, 0x05, 0x1B, 0x78, 0x3A, 0xE6, 0xFE, 0x08, 0xE6, 0xFF, 0x78,
	0x38, 0xE6, 0xFC, 0x08, 0xE6, 0xFD, 0x12, 0x03, 0x9C, 0x50, 0x21, 0x78,
	0x3C, 0xE6, 0x44, 0x01, 0xF6, 0x80, 0x19, 0x78, 0x3A, 0xE6, 0xFE, 0x08,
	0xE6, 0xFF, 0x78, 0x38, 0xE6, 0xFC, 0x08, 0xE6, 0xFD, 0x12, 0x03, 0xD4,
	0x50, 0x06, 0x78, 0x3C, 0xE6, 0x44, 0x02, 0xF6, 0x43, 0xDF, 0x04, 0xD2,
	0x02, 0xE4, 0x78, 0x3E, 0xF6, 0x22, 0x53, 0xDF, 0xFB, 0x00, 0x90, 0x21,
	0x47, 0xE0, 0xF5, 0xDE, 0xE5, 0xDD, 0x20, 0xE4, 0xFB, 0xE5, 0xDE, 0x00,
	0x43, 0xDF, 0x04, 0x22, 0x53, 0xDF, 0xFB, 0x00, 0x75, 0xDE, 0x05, 0xE5,
	0xDD, 0x20, 0xE4, 0xFB, 0xE5, 0xDE, 0x75, 0xDE, 0xFF, 0xE5, 0xDD, 0x20,
	0xE4, 0xFB, 0xE5, 0xDE, 0x20, 0xE0, 0xF3, 0x00, 0x43, 0xDF, 0x04, 0x22,
	0xED, 0x70, 0x04, 0xEC, 0x60, 0x31, 0x1C, 0x8F, 0x82, 0x8E, 0x83, 0xC3,
	0x79, 0x04, 0xE0, 0xF5, 0xDE, 0xA3, 0x1D, 0xED, 0x70, 0x04, 0xEC, 0x60,
	0x0D, 0x1C, 0xD9, 0xF2, 0xE5, 0xDD, 0x20, 0xE4, 0xFB, 0x54, 0x60, 0x60,
	0xE7, 0xD3, 0xE5, 0xDD, 0x20, 0xE4, 0xFB, 0x20, 0xE0, 0x04, 0xE5, 0xDE,
	0x80, 0xF4, 0x54, 0x60, 0x60, 0x01, 0xD3, 0x22, 0xED, 0x70, 0x04, 0xEC,
	0x60, 0x2B, 0x1C, 0x8F, 0x82, 0x8E, 0x83, 0xE4, 0x1D, 0xF5, 0xDE, 0xD3,
	0xED, 0x70, 0x04, 0xEC, 0x60, 0x02, 0x1C, 0xC3, 0xE5, 0xDD, 0x20, 0xE0,
	0xFB, 0x54, 0x60, 0x70, 0x0D, 0xE5, 0xDE, 0x40, 0x03, 0xF5, 0xDE, 0x1D,
	0xF0, 0xA3, 0x50, 0xE3
};

static uint8_t aes_decrypt[1024], aes_encrypt[1024];

static int aes_setup(struct cipher_ctx *ctx, enum cipher_mode opmode,
						int keybitSize, enum cipher_op encrypt)
{
	ctx->ops.cipher_mode = opmode;
	ctx->key.bit_stream = (uint8_t *)au32MyAESKey;
	ctx->keylen = keybitSize;
	ctx->flags = CAP_RAW_KEY | CAP_SYNC_OPS | CAP_SEPARATE_IO_BUFS;
	return(cipher_begin_session(aes_dev, ctx, CRYPTO_CIPHER_ALGO_AES,
				opmode, encrypt));
}

static int aes_test(int keysize, enum cipher_mode opmode)
{
	int ret;
	struct cipher_ctx ctx;
	struct cipher_pkt pkt;

	for (ret = 0; ret < 1024; ret++)
		aes_encrypt[ret] = 0;

	ret = aes_setup(&ctx, opmode, keysize, CRYPTO_CIPHER_OP_ENCRYPT);
	if (ret == 0) {
		pkt.in_buf = (uint8_t *)au8InputData;
		pkt.out_buf = aes_encrypt;
		pkt.in_len = 1024;
		pkt.out_buf_max = 1024;
		pkt.ctx = &ctx;
		if (opmode == CRYPTO_CIPHER_MODE_CTR)
			ctx.ops.ctr_crypt_hndlr(&ctx, &pkt, NULL);
		else if (opmode == CRYPTO_CIPHER_MODE_CBC)
			ctx.ops.cbc_crypt_hndlr(&ctx, &pkt, NULL);
		else
			ctx.ops.block_crypt_hndlr(&ctx, &pkt);
	} else {
		LOG_INF("Encrypt FAIL mode:%d size:%d", opmode, keysize);
		return -1;
	}
	for (ret = 0; ret < 1024; ret++) {
		if (aes_encrypt[ret] != 0)
			break;
	}
	LOG_INF("Encryption state %s", (ret == 1024) ? "[FAIL]" : "[PASS]");
	ret = aes_setup(&ctx, opmode, keysize, CRYPTO_CIPHER_OP_DECRYPT);
	if (ret == 0) {
		pkt.in_buf = aes_encrypt;
		pkt.out_buf = aes_decrypt;
		pkt.in_len = 1024;
		pkt.out_buf_max = 1024;
		pkt.ctx = &ctx;
		if (opmode == CRYPTO_CIPHER_MODE_CTR)
			ctx.ops.ctr_crypt_hndlr(&ctx, &pkt, NULL);
		else if (opmode == CRYPTO_CIPHER_MODE_CBC)
			ctx.ops.cbc_crypt_hndlr(&ctx, &pkt, NULL);
		else
			ctx.ops.block_crypt_hndlr(&ctx, &pkt);
	} else {
		LOG_INF("Decrypt FAIL mode:%d size:%d", opmode, keysize);
		return -1;
	}
	return 0;
}
static void aes_validation_func(void *dummy1, void *dummy2, void *dummy3)
{
	uint32_t i, events, keysize;

	k_event_init(&aes_event);
	while (true) {
		events = k_event_wait(&aes_event, 0xFFF, true, K_FOREVER);
		switch (events) {
		case 0x001: /* no argu */
			break;
		case 0x002: /* one argu */
			break;
		case 0x004: /* two argu */
			for (i = 0; i < 1024; i++)
				aes_decrypt[i] = 0;
			keysize = atoi(arguments[0]);
			if (!strcmp("ECB", arguments[1]))
				aes_test(keysize, CRYPTO_CIPHER_MODE_ECB);
			else if (!strcmp("CBC", arguments[1]))
				aes_test(keysize, CRYPTO_CIPHER_MODE_CBC);
			else if (!strcmp("CTR", arguments[1]))
				aes_test(keysize, CRYPTO_CIPHER_MODE_CTR);
			else {
				LOG_INF("[FAIL] mode not support");
				break;
			}
			for (i = 0; i < 1024; i++) {
				if (aes_decrypt[i] != au8InputData[i])
					break;
			}
			if (i == 1024)
				LOG_INF("[PASS] AES %s mode key length %d bit", arguments[1],
						keysize);
			else
				LOG_INF("[FAIL] at %d (%02x:%02x)", i, aes_decrypt[i],
						au8InputData[i]);
			break;
		case 0x008: /* three argu */
			break;
		}
	}
}

void main(void)
{
	/* Zephyr driver validation */
	LOG_INF("Start AES Validation Task\n");
	k_thread_create(&temp_id, temp_stack, TASK_STACK_SIZE, aes_validation_func, NULL, NULL,
			NULL, PRIORITY, K_INHERIT_PERMS, K_FOREVER);
	k_thread_name_set(&temp_id, "AES Validation");
	k_thread_start(&temp_id);
}
static int aes_command(const struct shell *shell, size_t argc, char **argv)
{
	int i, evt;

	evt = 1;
	for (evt = 1, i = 1; i < argc; i++) {
		strcpy(arguments[i - 1], argv[i]);
		evt <<= 1;
	}
	k_event_post(&aes_event, evt);
	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(sub_aes,
	SHELL_CMD_ARG(c0, NULL, "aes c0", aes_command, 1, 0),
	SHELL_CMD_ARG(c1, NULL, "aes c1 arg0", aes_command, 2, 0),
	SHELL_CMD_ARG(c2, NULL, "aes c2 arg0 arg1", aes_command, 3, 0),
	SHELL_CMD_ARG(c3, NULL, "aes c3 arg0 arg1 arg2", aes_command, 4, 0),
	SHELL_SUBCMD_SET_END /* Array terminated. */
);
SHELL_CMD_REGISTER(aes, &sub_aes, "AES validation commands", NULL);
